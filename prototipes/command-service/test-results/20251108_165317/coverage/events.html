
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>events: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">command-service/internal/events/event_publisher.go (100.0%)</option>
				
				<option value="file1">command-service/internal/events/kafka_publisher.go (23.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package events

import (
        "context"

        "go.uber.org/zap"
)

// EventPublisher defines the interface for publishing domain events
type EventPublisher interface {
        Publish(ctx context.Context, event interface{}) error
}

// Event represents a base event structure
type Event struct {
        EventType  string
        OccurredAt interface{}
}

// Inventory domain events
type InventoryItemCreatedEvent struct {
        ItemID      interface{}
        SKU         string
        Name        string
        Description string
        Quantity    int
        OccurredAt  interface{}
}

type InventoryItemUpdatedEvent struct {
        ItemID      interface{}
        Name        string
        Description string
        OccurredAt  interface{}
}

type InventoryItemDeletedEvent struct {
        ItemID     interface{}
        SKU        string
        OccurredAt interface{}
}

type StockAdjustedEvent struct {
        ItemID     interface{}
        SKU        string
        Quantity   int
        NewTotal   int
        OccurredAt interface{}
}

type StockReservedEvent struct {
        ItemID     interface{}
        SKU        string
        Quantity   int
        Reserved   int
        Available  int
        OccurredAt interface{}
}

type StockReleasedEvent struct {
        ItemID     interface{}
        SKU        string
        Quantity   int
        Reserved   int
        Available  int
        OccurredAt interface{}
}

// InMemoryEventPublisher is a placeholder implementation
// TODO: Replace with actual event broker implementation (Kafka, RabbitMQ, etc.)
type InMemoryEventPublisher struct {
        logger *zap.Logger
        events []interface{}
}

func NewEventPublisher() EventPublisher <span class="cov8" title="1">{
        return &amp;InMemoryEventPublisher{
                logger: zap.NewNop(),
                events: make([]interface{}, 0),
        }
}</span>

func (p *InMemoryEventPublisher) Publish(ctx context.Context, event interface{}) error <span class="cov8" title="1">{
        // TODO: Implement actual event publishing to Kafka/RabbitMQ/etc.
        p.events = append(p.events, event)
        p.logger.Info("Event published (in-memory)", zap.Any("event", event))
        return nil
}</span>

</pre>
		
		<pre class="file" id="file1" style="display: none">package events

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "command-service/internal/config"

        "github.com/IBM/sarama"
        "github.com/google/uuid"
        "go.uber.org/zap"
)

// KafkaEventPublisher implements EventPublisher using Kafka
type KafkaEventPublisher struct {
        producer sarama.SyncProducer
        logger   *zap.Logger
        config   *config.Config
}

// NewKafkaEventPublisher creates a new Kafka event publisher
func NewKafkaEventPublisher(cfg *config.Config, logger *zap.Logger) (EventPublisher, error) <span class="cov0" title="0">{
        config := sarama.NewConfig()
        config.Producer.Return.Successes = true
        config.Producer.RequiredAcks = sarama.WaitForAll
        config.Producer.Retry.Max = cfg.KafkaRetries
        config.Producer.Idempotent = true
        config.Net.MaxOpenRequests = 1

        // Parse acks
        switch cfg.KafkaAcks </span>{
        case "0":<span class="cov0" title="0">
                config.Producer.RequiredAcks = sarama.NoResponse</span>
        case "1":<span class="cov0" title="0">
                config.Producer.RequiredAcks = sarama.WaitForLocal</span>
        case "all":<span class="cov0" title="0">
                config.Producer.RequiredAcks = sarama.WaitForAll</span>
        default:<span class="cov0" title="0">
                config.Producer.RequiredAcks = sarama.WaitForAll</span>
        }

        <span class="cov0" title="0">producer, err := sarama.NewSyncProducer(cfg.KafkaBrokers, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Kafka producer: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;KafkaEventPublisher{
                producer: producer,
                logger:   logger,
                config:   cfg,
        }, nil</span>
}

// Publish publishes an event to Kafka
func (p *KafkaEventPublisher) Publish(ctx context.Context, event interface{}) error <span class="cov0" title="0">{
        // Determine topic based on event type
        topic, err := p.getTopicForEvent(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to determine topic: %w", err)
        }</span>

        // Serialize event to JSON
        <span class="cov0" title="0">eventJSON, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        // Create Kafka message
        <span class="cov0" title="0">message := &amp;sarama.ProducerMessage{
                Topic: topic,
                Value: sarama.ByteEncoder(eventJSON),
                Headers: []sarama.RecordHeader{
                        {
                                Key:   []byte("event-type"),
                                Value: []byte(p.getEventType(event)),
                        },
                        {
                                Key:   []byte("event-id"),
                                Value: []byte(uuid.New().String()),
                        },
                        {
                                Key:   []byte("timestamp"),
                                Value: []byte(time.Now().UTC().Format(time.RFC3339)),
                        },
                },
        }

        // Set partition key if available
        if partitionKey := p.getPartitionKey(event); partitionKey != "" </span><span class="cov0" title="0">{
                message.Key = sarama.StringEncoder(partitionKey)
        }</span>

        // Send message
        <span class="cov0" title="0">partition, offset, err := p.producer.SendMessage(message)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Error("Failed to publish event to Kafka",
                        zap.String("topic", topic),
                        zap.Error(err),
                )
                return fmt.Errorf("failed to publish event to Kafka: %w", err)
        }</span>

        <span class="cov0" title="0">p.logger.Info("Event published to Kafka",
                zap.String("topic", topic),
                zap.Int32("partition", partition),
                zap.Int64("offset", offset),
                zap.String("event-type", p.getEventType(event)),
        )

        return nil</span>
}

// Close closes the Kafka producer
func (p *KafkaEventPublisher) Close() error <span class="cov0" title="0">{
        if p.producer != nil </span><span class="cov0" title="0">{
                return p.producer.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// getTopicForEvent determines the Kafka topic based on event type
func (p *KafkaEventPublisher) getTopicForEvent(event interface{}) (string, error) <span class="cov10" title="9">{
        switch event.(type) </span>{
        case InventoryItemCreatedEvent, InventoryItemUpdatedEvent, InventoryItemDeletedEvent:<span class="cov6" title="4">
                return p.config.KafkaTopicItems, nil</span>
        case StockAdjustedEvent, StockReservedEvent, StockReleasedEvent:<span class="cov6" title="4">
                return p.config.KafkaTopicStock, nil</span>
        default:<span class="cov1" title="1">
                return "", fmt.Errorf("unknown event type: %T", event)</span>
        }
}

// getEventType returns the event type as string
func (p *KafkaEventPublisher) getEventType(event interface{}) string <span class="cov10" title="9">{
        switch event.(type) </span>{
        case InventoryItemCreatedEvent:<span class="cov3" title="2">
                return "InventoryItemCreated"</span>
        case InventoryItemUpdatedEvent:<span class="cov1" title="1">
                return "InventoryItemUpdated"</span>
        case InventoryItemDeletedEvent:<span class="cov1" title="1">
                return "InventoryItemDeleted"</span>
        case StockAdjustedEvent:<span class="cov3" title="2">
                return "StockAdjusted"</span>
        case StockReservedEvent:<span class="cov1" title="1">
                return "StockReserved"</span>
        case StockReleasedEvent:<span class="cov1" title="1">
                return "StockReleased"</span>
        default:<span class="cov1" title="1">
                return "Unknown"</span>
        }
}

// getPartitionKey returns the partition key for the event (usually the item ID)
func (p *KafkaEventPublisher) getPartitionKey(event interface{}) string <span class="cov3" title="2">{
        switch e := event.(type) </span>{
        case InventoryItemCreatedEvent:<span class="cov3" title="2">
                if id, ok := e.ItemID.(string); ok </span><span class="cov1" title="1">{
                        return id
                }</span>
                <span class="cov1" title="1">if id, ok := e.ItemID.(uuid.UUID); ok </span><span class="cov1" title="1">{
                        return id.String()
                }</span>
        case InventoryItemUpdatedEvent:<span class="cov0" title="0">
                if id, ok := e.ItemID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
                <span class="cov0" title="0">if id, ok := e.ItemID.(uuid.UUID); ok </span><span class="cov0" title="0">{
                        return id.String()
                }</span>
        case InventoryItemDeletedEvent:<span class="cov0" title="0">
                if id, ok := e.ItemID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
                <span class="cov0" title="0">if id, ok := e.ItemID.(uuid.UUID); ok </span><span class="cov0" title="0">{
                        return id.String()
                }</span>
        case StockAdjustedEvent:<span class="cov0" title="0">
                if id, ok := e.ItemID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
                <span class="cov0" title="0">if id, ok := e.ItemID.(uuid.UUID); ok </span><span class="cov0" title="0">{
                        return id.String()
                }</span>
        case StockReservedEvent:<span class="cov0" title="0">
                if id, ok := e.ItemID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
                <span class="cov0" title="0">if id, ok := e.ItemID.(uuid.UUID); ok </span><span class="cov0" title="0">{
                        return id.String()
                }</span>
        case StockReleasedEvent:<span class="cov0" title="0">
                if id, ok := e.ItemID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
                <span class="cov0" title="0">if id, ok := e.ItemID.(uuid.UUID); ok </span><span class="cov0" title="0">{
                        return id.String()
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
