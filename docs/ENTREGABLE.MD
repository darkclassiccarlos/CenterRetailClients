# ENTREGABLE - Sistema de Gesti√≥n de Inventario

## üìã Resumen Ejecutivo

Este documento presenta la propuesta de migraci√≥n de un sistema monol√≠tico de gesti√≥n de inventario a una arquitectura distribuida basada en **CQRS (Command Query Responsibility Segregation)** y **Event-Driven Architecture (EDA)**, dise√±ada para resolver problemas cr√≠ticos de consistencia, latencia y escalabilidad.

---

## üèóÔ∏è Arquitectura Actual

### Descripci√≥n del Sistema Actual

La empresa mantiene un sistema de gesti√≥n de inventario para una cadena de tiendas minoristas con las siguientes caracter√≠sticas:

#### Componentes Principales

- **Backend Monol√≠tico**: Aplicaci√≥n √∫nica que maneja todas las operaciones (lectura y escritura)
- **Frontend Legacy**: Aplicaci√≥n web antigua que consume el backend monol√≠tico
- **Base de Datos Local por Tienda**: Cada tienda mantiene su propia base de datos local
- **Base de Datos Central**: Base de datos centralizada que almacena el inventario consolidado
- **Sincronizaci√≥n Peri√≥dica**: Proceso de sincronizaci√≥n que se ejecuta cada 15 minutos

#### Flujo de Operaci√≥n Actual

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Tienda 1  ‚îÇ         ‚îÇ   Tienda 2  ‚îÇ         ‚îÇ   Tienda N  ‚îÇ
‚îÇ  (DB Local) ‚îÇ         ‚îÇ  (DB Local) ‚îÇ         ‚îÇ  (DB Local) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                       ‚îÇ                       ‚îÇ
       ‚îÇ  Sincronizaci√≥n       ‚îÇ  Sincronizaci√≥n       ‚îÇ
       ‚îÇ  cada 15 minutos      ‚îÇ  cada 15 minutos      ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ                       ‚îÇ
                   ‚ñº                       ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Backend Monol√≠tico     ‚îÇ
         ‚îÇ  (Lectura + Escritura)  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Base de Datos Central  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Problemas Identificados

#### 1. **Inconsistencias de Stock**
- **Problema**: Las actualizaciones de stock se sincronizan cada 15 minutos, generando ventanas de inconsistencia
- **Impacto**: Los clientes pueden ver stock disponible que ya fue vendido, o viceversa
- **Consecuencia**: P√©rdida de ventas y frustraci√≥n del cliente

#### 2. **Alta Latencia en Actualizaciones**
- **Problema**: Los cambios de stock no se reflejan en tiempo real
- **Impacto**: Experiencia de usuario degradada, especialmente en operaciones de alta frecuencia
- **Consecuencia**: P√©rdida de competitividad frente a sistemas m√°s √°giles

#### 3. **Escalabilidad Limitada**
- **Problema**: El backend monol√≠tico no puede escalar independientemente para lectura y escritura
- **Impacto**: Cuellos de botella durante picos de carga
- **Consecuencia**: Necesidad de sobre-provisionar recursos

#### 4. **Acoplamiento Fuerte**
- **Problema**: Todas las operaciones est√°n acopladas en un solo servicio
- **Impacto**: Cambios en una funcionalidad afectan a todo el sistema
- **Consecuencia**: Dificultad para mantener y evolucionar el sistema

#### 5. **Puntos √önicos de Falla**
- **Problema**: Si el backend monol√≠tico falla, todo el sistema se detiene
- **Impacto**: Disponibilidad limitada
- **Consecuencia**: P√©rdida de servicio durante mantenimientos o fallos

---

## üöÄ Arquitectura Propuesta

### Visi√≥n General

La nueva arquitectura implementa **CQRS + Event-Driven Architecture** para separar las responsabilidades de lectura y escritura, garantizar consistencia eventual y mejorar la escalabilidad.

#### Principios Arquitect√≥nicos

1. **Separaci√≥n de Responsabilidades**: Comandos (escritura) y Queries (lectura) en servicios independientes
2. **Event-Driven**: Comunicaci√≥n as√≠ncrona mediante eventos
3. **Single Writer Principle**: Solo un servicio escribe en la fuente de verdad
4. **Optimistic Locking**: Control de concurrencia sin bloqueos pesimistas
5. **Cache-First**: Optimizaci√≥n de lecturas mediante cache distribuido

### Componentes de la Arquitectura

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        FRONTEND                                  ‚îÇ
‚îÇ  (Consume Query Service para lectura y Command Service para     ‚îÇ
‚îÇ   escritura - Reservas/Compras)                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ                           ‚îÇ
                ‚îÇ GET /stock                ‚îÇ POST /reserve
                ‚îÇ                           ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Query Service  ‚îÇ         ‚îÇ Command Service ‚îÇ
        ‚îÇ (API Lectura)  ‚îÇ         ‚îÇ (API Escritura) ‚îÇ
        ‚îÇ Puerto: 8081   ‚îÇ         ‚îÇ Puerto: 8080    ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ                           ‚îÇ
                ‚îÇ Lee desde                 ‚îÇ Publica eventos
                ‚îÇ                           ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  Redis Cache   ‚îÇ         ‚îÇ  Event Broker   ‚îÇ
        ‚îÇ  (Read Model)  ‚îÇ         ‚îÇ     (Kafka)     ‚îÇ
        ‚îÇ   (Opcional)   ‚îÇ         ‚îÇ                 ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                             ‚îÇ
                                             ‚îÇ Consume eventos
                                             ‚îÇ
                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    ‚îÇ Listener Service ‚îÇ
                                    ‚îÇ (Event Processor)‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                             ‚îÇ
                                             ‚îÇ Escribe (Single Writer)
                                             ‚îÇ
                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    ‚îÇ Inventory DB    ‚îÇ
                                    ‚îÇ (SQLite)        ‚îÇ
                                    ‚îÇ Fuente de Verdad‚îÇ
                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1. Command Service (API Escritura)

#### Responsabilidades

- **Recibe peticiones de escritura/comando** (POST /reserve, POST /adjust, etc.)
- **Valida la petici√≥n** seg√∫n reglas de negocio
- **Publica eventos en el Event Broker** (Kafka)
- **Retorna 202 Accepted inmediatamente** (procesamiento as√≠ncrono)

#### Caracter√≠sticas T√©cnicas

- **Puerto**: 8080
- **Protocolo**: HTTP REST
- **Respuesta**: 202 Accepted (as√≠ncrono)
- **Eventos Publicados**:
  - `inventory.items.created`
  - `inventory.items.updated`
  - `inventory.items.deleted`
  - `inventory.stock.adjusted`
  - `inventory.stock.reserved`
  - `inventory.stock.released`

#### Flujo de Operaci√≥n

```
1. Cliente ‚Üí POST /api/v1/inventory/items/:id/reserve
2. Command Service valida la petici√≥n
3. Command Service publica evento StockReserved en Kafka
4. Command Service retorna 202 Accepted
5. Cliente recibe confirmaci√≥n inmediata
```

#### Beneficios

- **Baja Latencia de Respuesta**: Respuesta inmediata sin esperar procesamiento
- **Alta Disponibilidad**: No bloquea operaciones de lectura
- **Desacoplamiento**: No depende de la base de datos para responder

---

### 2. Query Service (API Lectura)

#### Responsabilidades

- **Recibe peticiones de consulta** (GET /stock, GET /items, etc.)
- **Lee directamente de Redis Cache** para latencia m√≠nima
- **Fallback a Read Model** si el cache no est√° disponible
- **Optimizado para alta frecuencia de lectura**

#### Caracter√≠sticas T√©cnicas

- **Puerto**: 8081
- **Protocolo**: HTTP REST
- **Estrategia**: Cache-First
- **Cache**: Redis (opcional, con fallback a in-memory)
- **TTL**: Configurable (default: 5 minutos)

#### Flujo de Operaci√≥n

```
1. Cliente ‚Üí GET /api/v1/inventory/items/:id/stock
2. Query Service consulta Redis Cache
3. Si existe en cache ‚Üí Retorna inmediatamente
4. Si no existe ‚Üí Consulta Read Model y actualiza cache
5. Retorna respuesta al cliente
```

#### Beneficios

- **Ultra Baja Latencia**: Respuestas en milisegundos desde cache
- **Alta Escalabilidad**: Stateless, escalable horizontalmente
- **Alta Disponibilidad**: M√∫ltiples instancias pueden servir requests

---

### 3. Event Broker (Kafka)

#### Responsabilidades

- **Centraliza la comunicaci√≥n** entre servicios
- **Garantiza fiabilidad** mediante persistencia de eventos
- **Tolerancia a fallos**: Los eventos persisten hasta ser procesados
- **Ordenamiento**: Mantiene el orden de eventos por partici√≥n

#### Caracter√≠sticas T√©cnicas

- **Tecnolog√≠a**: Apache Kafka
- **Puertos**: 
  - 9092 (conexiones externas)
  - 9093 (conexiones externas alternativas)
  - 29093 (comunicaci√≥n interna entre brokers)
- **Topics**:
  - `inventory.items` (3 particiones)
  - `inventory.stock` (3 particiones)
  - `inventory.dlq` (1 partici√≥n - Dead Letter Queue)
- **Visualizaci√≥n**: Kafdrop en puerto 9000

#### Configuraci√≥n

```yaml
# docker-components/kafka/docker-compose.yml
- Zookeeper (puerto 2181)
- Kafka (puertos 9092, 9093, 29093)
- Kafdrop (puerto 9000) - Visualizaci√≥n web
- Kafka-init - Crea topics autom√°ticamente
```

#### Beneficios

- **Fiabilidad**: Eventos no se pierden
- **Desacoplamiento**: Servicios no se conocen directamente
- **Escalabilidad**: Procesamiento paralelo mediante particiones
- **Auditor√≠a**: Historial completo de eventos

---

### 4. Listener Service (Event Processor)

#### Responsabilidades

- **Consume eventos del Event Broker** (Kafka)
- **Es el √∫nico que escribe en la BD** (Single Writer Principle)
- **Aplica l√≥gica de Bloqueo Optimista** para manejar concurrencia
- **Garantiza Consistencia Estricta (CP)** en la fuente de verdad

#### Caracter√≠sticas T√©cnicas

- **Single Writer Principle**: Solo este servicio escribe en SQLite
- **Optimistic Locking**: Usa campo `version` para control de concurrencia
- **Retry Logic**: Reintentos autom√°ticos con backoff exponencial
- **Dead Letter Queue**: Manejo de eventos fallidos

#### Flujo de Procesamiento

```
1. Listener Service consume evento de Kafka
2. Extrae tipo de evento y datos
3. Aplica l√≥gica de negocio (validaciones)
4. Intenta actualizar SQLite con optimistic locking
5. Si hay conflicto de versi√≥n ‚Üí Reintenta
6. Si falla despu√©s de reintentos ‚Üí Env√≠a a DLQ
7. Commit del offset en Kafka
```

#### Optimistic Locking

```sql
UPDATE inventory_items
SET quantity = quantity + ?, 
    version = version + 1,
    updated_at = ?
WHERE id = ? 
  AND version = ? 
  AND (quantity + ?) >= 0
```

Si la versi√≥n no coincide, la actualizaci√≥n falla y se reintenta autom√°ticamente.

#### Beneficios

- **Consistencia Garantizada**: Solo un escritor evita conflictos
- **Alta Concurrencia**: Optimistic locking permite procesamiento paralelo
- **Tolerancia a Fallos**: Reintentos autom√°ticos y DLQ

---

### 5. Inventory Database (SQLite)

#### Responsabilidades

- **Fuente de Verdad (Single Source of Truth)**
- **Almacena el stock real** con control de versi√≥n
- **Solo escritura desde Listener Service** (Single Writer Principle)
- **Consistencia Estricta (CP)**

#### Caracter√≠sticas T√©cnicas

- **Tecnolog√≠a**: SQLite
- **Esquema**: Tabla `inventory_items` con campo `version`
- **Control de Concurrencia**: Optimistic locking mediante `version`
- **Escritor √önico**: Solo Listener Service puede escribir

#### Esquema de Base de Datos

```sql
CREATE TABLE inventory_items (
    id TEXT PRIMARY KEY,
    sku TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    quantity INTEGER NOT NULL DEFAULT 0,
    reserved_quantity INTEGER NOT NULL DEFAULT 0,
    version INTEGER NOT NULL DEFAULT 1,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL
);
```

#### Beneficios

- **Consistencia**: Garantiza que el stock siempre sea correcto
- **Simplicidad**: SQLite es ligero y f√°cil de mantener
- **Auditor√≠a**: Campo `version` permite rastrear cambios

---

### 6. Read Model / Cache (Redis - Opcional)

#### Responsabilidades

- **Base de datos de solo lectura** optimizada para consultas r√°pidas
- **Se actualiza en tiempo real** impulsada por eventos desde el Listener
- **Cache distribuido** para alta disponibilidad
- **Fallback a in-memory** si Redis no est√° disponible

#### Caracter√≠sticas T√©cnicas

- **Tecnolog√≠a**: Redis (opcional)
- **Estrategia**: Cache-First
- **TTL**: Configurable por tipo de dato
- **Actualizaci√≥n**: Event-driven desde Listener Service

#### Nota Importante

**La actualizaci√≥n de Redis es opcional**, por lo que los prototipos est√°n dise√±ados para funcionar sin Redis, usando implementaciones in-memory como fallback. Esto permite:

- **Desarrollo sin dependencias externas**: Los servicios funcionan sin Redis
- **Flexibilidad**: Puede habilitarse Redis en producci√≥n para mejor performance
- **Resiliencia**: El sistema funciona aunque Redis falle

#### Beneficios

- **Ultra Baja Latencia**: Respuestas en milisegundos
- **Alta Escalabilidad**: Cache distribuido
- **Resiliencia**: Fallback autom√°tico si Redis no est√° disponible

---

## üìä Comparaci√≥n: Arquitectura Actual vs Propuesta

| Aspecto | Arquitectura Actual | Arquitectura Propuesta |
|---------|---------------------|------------------------|
| **Consistencia** | Eventual (sincronizaci√≥n cada 15 min) | Eventual con garant√≠as (tiempo real) |
| **Latencia de Lectura** | Alta (consulta a BD central) | Ultra baja (cache Redis) |
| **Latencia de Escritura** | Alta (escritura s√≠ncrona) | Baja (202 Accepted inmediato) |
| **Escalabilidad** | Limitada (monol√≠tico) | Alta (servicios independientes) |
| **Disponibilidad** | Punto √∫nico de falla | Alta (servicios desacoplados) |
| **Acoplamiento** | Fuerte | Bajo (event-driven) |
| **Mantenibilidad** | Dif√≠cil | F√°cil (separaci√≥n de responsabilidades) |
| **Tolerancia a Fallos** | Baja | Alta (eventos persistentes) |
| **Auditor√≠a** | Limitada | Completa (historial de eventos) |

---

## üéØ Justificaci√≥n de la Migraci√≥n

### Problemas Resueltos

#### 1. **Inconsistencias de Stock**
- **Soluci√≥n**: Event-driven con procesamiento en tiempo real
- **Resultado**: Stock siempre consistente, sin ventanas de 15 minutos

#### 2. **Alta Latencia**
- **Soluci√≥n**: Cache-First en Query Service + procesamiento as√≠ncrono
- **Resultado**: Lecturas en milisegundos, escrituras con 202 Accepted

#### 3. **Escalabilidad Limitada**
- **Soluci√≥n**: Servicios independientes escalables horizontalmente
- **Resultado**: Escalar lectura y escritura independientemente

#### 4. **Acoplamiento Fuerte**
- **Soluci√≥n**: Event-driven architecture
- **Resultado**: Servicios desacoplados, cambios aislados

#### 5. **Puntos √önicos de Falla**
- **Soluci√≥n**: Servicios independientes con fallbacks
- **Resultado**: Alta disponibilidad, degradaci√≥n gradual

### Beneficios Adicionales

- **Mejor Experiencia de Usuario**: Respuestas instant√°neas
- **Mayor Confiabilidad**: Eventos persistentes, no se pierden datos
- **Facilidad de Mantenimiento**: C√≥digo organizado por responsabilidades
- **Preparado para el Futuro**: Arquitectura moderna y escalable

---

## üì¶ Estado del Proyecto y Prototipos

### Prototipos Implementados

#### 1. Command Service ‚úÖ

**Ubicaci√≥n**: `prototipes/command-service/`

**Estado**: ‚úÖ Implementado y funcional

**Caracter√≠sticas**:
- API REST completa con documentaci√≥n Swagger
- Publicaci√≥n de eventos a Kafka
- Validaciones de negocio
- Manejo de errores robusto
- Tests unitarios e integraci√≥n

**Endpoints**:
- `POST /api/v1/inventory/items` - Crear item
- `POST /api/v1/inventory/items/:id/reserve` - Reservar stock
- `POST /api/v1/inventory/items/:id/release` - Liberar stock
- `POST /api/v1/inventory/items/:id/adjust` - Ajustar stock

**Puerto**: 8080

**Documentaci√≥n**: `prototipes/command-service/docs/`

---

#### 2. Query Service ‚úÖ

**Ubicaci√≥n**: `prototipes/query-service/`

**Estado**: ‚úÖ Implementado y funcional

**Caracter√≠sticas**:
- API REST optimizada para lectura
- Cache-First con Redis (opcional, fallback a in-memory)
- Paginaci√≥n
- Documentaci√≥n Swagger
- Stateless y escalable

**Endpoints**:
- `GET /api/v1/inventory/items` - Listar items (paginado)
- `GET /api/v1/inventory/items/:id` - Obtener item por ID
- `GET /api/v1/inventory/items/:id/stock` - Obtener estado de stock

**Puerto**: 8081

**Documentaci√≥n**: `prototipes/query-service/docs/`

---

#### 3. Listener Service ‚úÖ

**Ubicaci√≥n**: `prototipes/listener-service/`

**Estado**: ‚úÖ Implementado y funcional

**Caracter√≠sticas**:
- Consumo de eventos de Kafka
- Single Writer Principle
- Optimistic Locking
- Retry logic con backoff
- Dead Letter Queue (DLQ)
- Base de datos SQLite

**Funcionalidades**:
- Procesa eventos de items (created, updated, deleted)
- Procesa eventos de stock (adjusted, reserved, released)
- Actualiza SQLite con control de versi√≥n
- Manejo de errores y DLQ

**Documentaci√≥n**: `prototipes/listener-service/SCHEMA.md`

---

#### 4. Event Broker (Kafka) ‚úÖ

**Ubicaci√≥n**: `docker-components/kafka/`

**Estado**: ‚úÖ Configurado y funcional

**Componentes**:
- Zookeeper (puerto 2181)
- Kafka (puertos 9092, 9093, 29093)
- Kafdrop (puerto 9000) - Visualizaci√≥n web
- Kafka-init - Inicializaci√≥n autom√°tica de topics

**Topics Configurados**:
- `inventory.items` (3 particiones)
- `inventory.stock` (3 particiones)
- `inventory.dlq` (1 partici√≥n)

**Configuraci√≥n**: `docker-components/kafka/docker-compose.yml`

---

### Componentes Opcionales

#### Redis Cache (Opcional)

**Estado**: ‚ö†Ô∏è Opcional - Los servicios funcionan sin Redis

**Implementaci√≥n**:
- Query Service tiene interfaz para Redis
- Fallback autom√°tico a in-memory si Redis no est√° disponible
- Permite desarrollo sin dependencias externas

**Configuraci√≥n**:
- Variables de entorno: `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD`
- Si no se configura, usa implementaci√≥n in-memory

---

## üöÄ Gu√≠a de Inicio R√°pido para Evaluadores

### Prerrequisitos

- **Go 1.20 o superior**
- **Docker y Docker Compose**
- **Git**

### Paso 1: Levantar Kafka

```bash
cd docker-components/kafka
docker compose up -d
```

Verificar que Kafka est√© corriendo:
- Kafdrop: http://localhost:9000
- Kafka: localhost:9092

### Paso 2: Ejecutar Listener Service

```bash
cd prototipes/listener-service
go run cmd/listener/main.go
```

Este servicio consumir√° eventos de Kafka y actualizar√° SQLite.

### Paso 3: Ejecutar Command Service

```bash
cd prototipes/command-service
go run cmd/api/main.go
```

El servicio estar√° disponible en: http://localhost:8080
- Swagger: http://localhost:8080/swagger/index.html

### Paso 4: Ejecutar Query Service

```bash
cd prototipes/query-service
go run cmd/api/main.go
```

El servicio estar√° disponible en: http://localhost:8081
- Swagger: http://localhost:8081/swagger/index.html

### Paso 5: Probar el Flujo Completo

#### 1. Crear un item (Command Service)

```bash
curl -X POST http://localhost:8080/api/v1/inventory/items \
  -H "Content-Type: application/json" \
  -d '{
    "sku": "PROD-001",
    "name": "Producto de Prueba",
    "description": "Descripci√≥n del producto",
    "quantity": 100
  }'
```

#### 2. Consultar stock (Query Service)

```bash
curl http://localhost:8081/api/v1/inventory/items/sku/PROD-001/stock
```

#### 3. Reservar stock (Command Service)

```bash
curl -X POST http://localhost:8080/api/v1/inventory/items/{id}/reserve \
  -H "Content-Type: application/json" \
  -d '{
    "quantity": 10
  }'
```

#### 4. Verificar actualizaci√≥n (Query Service)

```bash
curl http://localhost:8081/api/v1/inventory/items/{id}/stock
```

### Visualizaci√≥n

- **Kafdrop**: http://localhost:9000 - Ver eventos en Kafka
- **Command Service Swagger**: http://localhost:8080/swagger/index.html
- **Query Service Swagger**: http://localhost:8081/swagger/index.html

---

## üìö Documentaci√≥n Adicional

### Documentaci√≥n por Servicio

- **Command Service**: `prototipes/command-service/README.md`
- **Query Service**: `prototipes/query-service/README.md`
- **Listener Service**: `prototipes/listener-service/README.md`

### Documentaci√≥n T√©cnica

- **Eventos**: `prototipes/command-service/docs/EVENTS.md`
- **Errores**: `prototipes/command-service/docs/ERRORS.md`
- **Ejemplos**: `prototipes/command-service/docs/EXAMPLES.md`
- **Esquema BD**: `prototipes/listener-service/SCHEMA.md`
- **Configuraci√≥n Kafka**: `prototipes/CONFIGURACION_KAFKA.md`

### Diagramas

- **Arquitectura Distribuida**: `docs/arqDistribuida.png`

---

## üéì Conceptos Clave Implementados

### CQRS (Command Query Responsibility Segregation)

- **Separaci√≥n clara** entre comandos (escritura) y queries (lectura)
- **Command Service**: Solo comandos (POST, PUT, DELETE)
- **Query Service**: Solo queries (GET)

### Event-Driven Architecture (EDA)

- **Comunicaci√≥n as√≠ncrona** mediante eventos
- **Desacoplamiento** entre servicios
- **Eventos persistentes** en Kafka

### Single Writer Principle

- **Solo Listener Service** escribe en SQLite
- **Evita conflictos** de escritura
- **Garantiza consistencia**

### Optimistic Locking

- **Control de concurrencia** mediante campo `version`
- **Sin bloqueos pesimistas**
- **Alta concurrencia** permitida

### Cache-First Strategy

- **Redis como cache** (opcional)
- **Fallback autom√°tico** si Redis no est√° disponible
- **Ultra baja latencia** en lecturas

---

## üîÆ Pr√≥ximos Pasos y Mejoras Futuras

### Corto Plazo

1. **Implementar Redis real** (actualmente opcional)
2. **M√©tricas y observabilidad** (Prometheus, Grafana)
3. **Tests end-to-end** automatizados
4. **Documentaci√≥n de despliegue** en producci√≥n

### Mediano Plazo

1. **Migraci√≥n de base de datos** (PostgreSQL en lugar de SQLite)
2. **Replicaci√≥n de Read Model** para alta disponibilidad
3. **Circuit breakers** para resiliencia
4. **Rate limiting** en APIs

### Largo Plazo

1. **Microservicios adicionales** (notificaciones, reportes)
2. **Event sourcing** completo
3. **Saga pattern** para transacciones distribuidas
4. **Multi-regi√≥n** para alta disponibilidad global

---

## üìù Conclusiones

La arquitectura propuesta resuelve los problemas cr√≠ticos del sistema actual mediante:

1. **Separaci√≥n de responsabilidades** (CQRS)
2. **Comunicaci√≥n as√≠ncrona** (Event-Driven)
3. **Optimizaci√≥n de lecturas** (Cache-First)
4. **Consistencia garantizada** (Single Writer + Optimistic Locking)
5. **Alta escalabilidad** (servicios independientes)

Los prototipos implementados demuestran la viabilidad de la soluci√≥n y proporcionan una base s√≥lida para la migraci√≥n completa del sistema.

---

## üë• Contacto y Soporte

Para preguntas o aclaraciones sobre este entregable, por favor contactar al equipo de desarrollo.

**Fecha de Entrega**: [Fecha]
**Versi√≥n**: 1.0
**Estado**: Prototipos Funcionales ‚úÖ

